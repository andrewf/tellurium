use std::io;
use std::io::Write;
use std::convert::From;
use parsetree::*;
use flowgraph;
use common::*;

use flowgraph::*;

#[derive(Debug)]
pub enum CodeGenError {
    Io(io::Error),
    Other(String)
}

impl From<io::Error> for CodeGenError {
    fn from(e: io::Error) -> Self {
        CodeGenError::Io(e)
    }
}

pub fn mkcgerr<S: ToString + ?Sized, T>(s: &S) -> Result<T, CodeGenError> {
    Err(CodeGenError::Other(s.to_string()))
}

pub fn codegen_x86<W: Write>(out: &mut W, prog: CheckedProgram)
    -> Result<(), CodeGenError>
{
    try!(writeln!(out, "; generated by Tellurium"));
    try!(writeln!(out, "section .data"));
    // TODO vars
    for v in prog.global_vars.iter() {
        match (&v.datatype, &v.init) {
            // only support int data types for now
            // assume that's what Basic means
            (&DataType::Basic(_), &Expression::Literal(ref val)) => {
                try!(writeln!(out, "{}:", v.ld_name));
                try!(writeln!(out, "        dw {}", val));
            }
            (ref t, ref i) => {
                return mkcgerr(&format!(
                    "unsupported var type {:?} {:?}", t, i));
            }
        }
    }
    try!(writeln!(out, "section .text"));
    // externs
    for ex in prog.externs.iter() {
        try!(writeln!(out, "        extern {}", ex));
    }
    // functions
    for fun in prog.function_definitions {
        try!(writeln!(out, "global {}", fun.ld_name));
        try!(writeln!(out, "{}:", fun.ld_name));
        // we should generate code that depends on fun.signature
        // but we won't yet
        for stmt in fun.body.stmts.iter() {
            match stmt.action {
                NodeAction::Call(Location::Labeled(ref s), _) => {
                    // ignore signature some more
                    try!(writeln!(out, "        call {}", s));
                }
                NodeAction::Assign(ref address) => {
                    if stmt.inputs.len() != 1 {
                        return mkcgerr("assignment must have exactly one input")
                    }
                    match &stmt.inputs[0] {
                        &flowgraph::Location::Labeled(ref label) => {
                            // copy [label] to [address]
                            try!(writeln!(out, "        mov eax, [{}]", label));
                            try!(writeln!(out, "        mov [{}], eax", address));
                        }
                        _ => {
                            return mkcgerr("unsupported assignment")
                        }
                    }
                }
                NodeAction::Return => {
                    try!(writeln!(out, "        ret"));
                }
                _ => {
                    return mkcgerr("unsupported instruction")
                }
            }
        }
    }
    Ok(())
}

