use std::io;
use std::io::Write;
use std::convert::From;

use flowgraph::*;

pub enum CodeGenError {
    Io(io::Error),
    Other(String)
}

impl From<io::Error> for CodeGenError {
    fn from(e: io::Error) -> Self {
        CodeGenError::Io(e)
    }
}

pub fn mkcgerror<S: ToString>(s: S) -> CodeGenError {
    CodeGenError::Other(s.to_string())
}

pub fn codegen_x86<W: Write>(out: &mut W, prog: CheckedProgram)
    -> Result<(), CodeGenError>
{
    try!(writeln!(out, "; generated by Tellurium"));
    try!(writeln!(out, "section .data"));
    // TODO vars
    try!(writeln!(out, "section .text"));
    // externs
    for ex in prog.externs.iter() {
        try!(writeln!(out, "        extern {}", ex));
    }
    // functions
    for fun in prog.function_definitions {
        try!(writeln!(out, "global {}", fun.ld_name));
        try!(writeln!(out, "{}:", fun.ld_name));
        // we should generate code that depends on fun.signature
        // but we won't yet
        for stmt in fun.body.stmts.iter() {
            match stmt.action {
                NodeAction::Call(Location::Labeled(ref s), _) => {
                    // ignore signature some more
                    try!(writeln!(out, "        call {}", s));
                }
                NodeAction::Return => {
                    try!(writeln!(out, "        ret"));
                }
                _ => {
                    return Err(mkcgerror("unsupported instruction"))
                }
            }
        }
    }
    Ok(())
}

//pub trait CodeGenerator {
//    fn emit(TopLevel&) -> Result<(), CodeGenError>;
//}
